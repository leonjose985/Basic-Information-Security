**Лабораторная работа**  **N**** ° 5**

Информационная безопасность

Леон Фернандо Хосе Фернандо | НПМбд02-20

# **Содержание**

[**1 Цель работы** 4](#_Toc147541021)

[**2 Теоретическое введение** 4](#_Toc147541022)

[**3 Выполнение лабораторной работы** 4](#_Toc147541023)

[**3.1 Создание программы** 4](#_Toc147541024)

[**3.2Исследование**  **Sticky**** -бита** 10](#_Toc147541025)

[**4 Выводы** 12](#_Toc147541026)

[**5 Список Литературы** 12](#_Toc147541027)

**Список иллюстраций**

[Рисунок 1. Предварительная подготовка 5](#_Toc147541074)

[Рисунок 2. Команда "whereis" 5](#_Toc147541075)

[Рисунок 3.Вход в систему и создание программы 6](#_Toc147541076)

[Рисунок 4. Код программы simpleid.c 6](#_Toc147541077)

[Рисунок 5. Компиляция и выполнение программы simpleid 6](#_Toc147541078)

[Рисунок 6. Усложнение программы 7](#_Toc147541079)

[Рисунок 7. Переименование программы в simpleid2.c 7](#_Toc147541080)

[Рисунок 8. Компиляция и выполнение программы simpleid2 7](#_Toc147541081)

[Рисунок 9. Установка новых атрибутов (SetUID) 8](#_Toc147541082)

[Рисунок 10. Запуск simpleid2 после установки SetUID 8](#_Toc147541083)

[Рисунок 11. Запуск simpleid2 после установки SetGID 8](#_Toc147541084)

[Рисунок 12. Код программы readfile.c 9](#_Toc147541085)

[Рисунок 13. Смена владельца и прав доступа у файла readfile.c 9](#_Toc147541086)

[Рисунок 14. Запуск программы readfile 10](#_Toc147541087)

[Рисунок 15. Создание файла file01.txt 10](#_Toc147541088)

[Рисунок 16. Попытка выполнить действия над файлом file01.txt от имени пользо. 11](#_Toc147541089)

[Рисунок 17. Удаление атрибута t (Sticky-бита) 11](#_Toc147541090)

[Рисунок 18. Возвращение атрибута t (Sticky-бита) 12](#_Toc147541091)

# **1**  **Цель работы**

Изучение механизмов модификации идентификатора, использования SetUID и Sticky bits. Получение практических навыков использования консольных команд с дополнительными атрибутами. Изучается работа механизма изменения идентификатора пользовательского процесса, а также влияние бита Sticky на запись и удаление файлов.

# **2 Теоретическое введение**

SetUID, SetGID и Sticky - это специальные типы разрешений позволяют задавать

расширенные права доступа на файлы или каталоги.

• SetUID (set user ID upon execution — «установка ID пользователя во время

выполнения) являются флагами прав доступа в Unix, которые разрешают

пользователям запускать исполняемые файлы с правами владельца испол-

няемого файла.

• SetGID (set group ID upon execution — «установка ID группы во время вы-

полнения») являются флагами прав доступа в Unix, которые разрешают

пользователям запускать исполняемые файлы с правами группы исполняе-

мого файла.

• Sticky bit в основном используется в общих каталогах, таких как /var или

/tmp, поскольку пользователи могут создавать файлы, читать и выполнять

их, принадлежащие другим пользователям, но не могут удалять файлы,

принадлежащие другим пользователям.

# **3 Выполнение лабораторной работы**

## **3.1 Создание программы**

Для начала я проверил наличие компилятора gcc, используя команду 'gcc -v'. Затем я отключил системные ограничения до следующей перезагрузки системы с помощью команды "sudo setenforce 0", после чего команда "getenforce" отобразила "Разрешающий".

![](RackMultipart20231007-1-9k1dwk_html_59c95271abc0172b.png)

_Рисунок 1. Предварительная подготовка_

Проверить успешное выполнение команд "whereisgcc" и "whereisg++" (их расположение).

![](RackMultipart20231007-1-9k1dwk_html_cbf79599442a0cd8.png)

_Рисунок 2. Команда "whereis"_

Я вошел в систему как пользователь "гость", используя команду "su - guest". Я создал программу под названием "simplied.c" с помощью команды "touch simple id.c" и открыл ее в редакторе, используя команду "gedit /home/guest/simpleid.c".

![](RackMultipart20231007-1-9k1dwk_html_b5bc2aab08bc424d.png)

_Рисунок 3.Вход в систему и создание программы_

Код программы выглядит следующим образом.

![](RackMultipart20231007-1-9k1dwk_html_3069b9b4135c39ab.png)

_Рисунок 4. Код программы simpleid.c_

Я скомпилировал программу и убедился, что программный файл был создан с помощью команды 'gccsimplied.cosimpleid". Я выполнил программу 'simpleid' с помощью команды './simpleid', а затем запустил системную программу 'id' с помощью команды 'id'. Результаты, полученные в результате выполнения обеих команд, совпали (uid=1001 и gid=1001).

![](RackMultipart20231007-1-9k1dwk_html_7643afccb0292ad1.png)

_Рисунок 5. Компиляция и выполнение программы simpleid_

Усложнила программу, добавив вывод действительных идентификаторов.

![](RackMultipart20231007-1-9k1dwk_html_af87c14e4d3ac1f6.png)

_Рисунок 6. Усложнение программы_

Получившуюся программу назвала simpleid2.c

![](RackMultipart20231007-1-9k1dwk_html_d27ce6e60273e221.png)

_Рисунок 7. Переименование программы в simpleid2.c_

Скомпилировала и запустила simpleid2.c командами "gcc simpleid2.c -o sipleid2"

и "./simpleid2".

![](RackMultipart20231007-1-9k1dwk_html_e6d6d50f86e4f426.png)

_Рисунок 8. Компиляция и выполнение программы simpleid2_

От имени суперпользователя я выполнил команды "sudochownroot:guest /home/guest/simpleid2" и "sudochmodu+s /home/guest/simpleid2". После этого я проверил правильность установки новых атрибутов и смену владельца файла 'simpleid2', используя команду 'sudols -l /home/guest/simpleid2'. Эти команды привели к изменению пользователя файла на "root" и установке бита SetUID.

![](RackMultipart20231007-1-9k1dwk_html_3326533ce7328443.png)

_Рисунок 9. Установка новых атрибутов (SetUID)_

Запустил программы simpleid2 и id. Теперь появились различия в uid

![](RackMultipart20231007-1-9k1dwk_html_149dbf12a7a2e464.png)

_Рисунок 10. Запуск simpleid2 после установки SetUID_

Проделал тоже самое относительно SetGID-бита. Также можем заметить раз-

личия с предыдущим пунктом.

![](RackMultipart20231007-1-9k1dwk_html_1814717dc03ef09f.png)

_Рисунок 11. Запуск simpleid2 после установки SetGID_

Создаем программу readfile.c

![](RackMultipart20231007-1-9k1dwk_html_167179bcf5fb6bb4.png)

_Рисунок 12. Код программы readfile.c_

Я скомпилировал созданную программу, используя команду 'gccreadfile.c -oreadfile'. Я изменил владельца файла 'readfile.c' с помощью команды 'sudochownroot:guest /home /гость / readfile.c' и настроил разрешения так, чтобы только суперпользователь мог его прочитать, в то время как 'гость' не мог, используя команду 'sudochmod 700 /home/гость/readfile.c'. Теперь я убедился, что пользователь "гость" не может прочитать файл "readfile.c" с помощью команды "catreadfile.c" и получил сообщение об ошибке "отказано в доступе".

![](RackMultipart20231007-1-9k1dwk_html_1725a14b89220a10.png)

_Рисунок 13. Смена владельца и прав доступа у файла readfile.c_

Я сменил владельца программы "readfile" и установил SetUID. Я проверил, может ли программа "readfile" прочитать файл "readfile.c", используя команду "./readfilereadfile.c". Он смог это прочитать. Аналогично, я проверил, возможно ли прочитать файл '/etc/shadow', и это также прошло успешно.

![](RackMultipart20231007-1-9k1dwk_html_46d0abc7adb20b18.png)

_Рисунок 14. Запуск программы readfile_

## **3.2Исследование**  **Sticky**** -бита**

Я подтвердил, что атрибут Sticky был установлен в каталоге '/tmp', используя команду 'ls -l / | grep tmp'. От имени пользователя "гость" я создал файл с именем 'file01.txt ' в каталоге '/tmp' со словом 'test' с помощью команды 'echo "test" \> /tmp/file01.txt '. Я проверил атрибуты вновь созданного файла и предоставил разрешения на чтение и запись для категории пользователей "все остальные", используя команды "ls -l /tmp/file01.txt ' и 'chmod o+rw /tmp/file01.txt '.

![](RackMultipart20231007-1-9k1dwk_html_d910b94daa0117f0.png)

_Рисунок 15. Создание файла file01.txt_

От имени пользователя "guest2" я попытался прочитать файл, используя команду "cat /tmp/file01.txt ", и это было успешно. Затем я попытался добавить слово "test2" к файлу, проверить его содержимое и записать в файл "test3", удалив при этом всю существующую информацию. Эти операции были успешными только тогда, когда я дополнительно предоставил разрешения на чтение и запись для "группы" пользователей, используя команду "chmodg+rw /tmp/file01.txt '. Однако, когда я попытался удалить файл от имени пользователя 'guest2', это не было возможно ни в одном из случаев, и произошла ошибка.

![](RackMultipart20231007-1-9k1dwk_html_9030a855d08d98f8.png)

_Рисунок 16. Попытка выполнить действия над файлом file01.txt от имени пользо._

Я повысил разрешения до статуса суперпользователя с помощью команды 'su -' и выполнил команду для удаления атрибута 't' из каталога '/tmp' с помощью 'chmod -t /tmp'. После этого я вышел из режима суперпользователя с помощью команды "exit". Я повторил предыдущие шаги. Теперь я смог удалить 'file01.txt " файл от имени пользователя, который не был его владельцем.

![](RackMultipart20231007-1-9k1dwk_html_c066e4fd9117fe7e.png)

_Рисунок 17. Удаление атрибута t (Sticky-бита)_

Повысила свои права до суперпользователя и вернула атрибут t на директорию

/tmp

![](RackMultipart20231007-1-9k1dwk_html_cc266aa09895239b.png)

_Рисунок 18. Возвращение атрибута t (Sticky-бита)_

# **4 Выводы**

Во время выполнения этого лабораторного задания я изучил механизмы модификации идентификаторов, применение SetUID и Stickybits, а также приобрел практические навыки использования консоли с дополнительными атрибутами. Я изучил работу механизма изменения идентификатора пользовательского процесса и влияние Sticky-бита на запись и удаление файлов.

# **5 Список Литературы**

1. Стандартные права SetUID, SetGID, Sticky в Linux [Электронный ресурс].

URL: https://linux-notes.org/standartny-e-prava-unix-suid-sgid-sticky-bity/.